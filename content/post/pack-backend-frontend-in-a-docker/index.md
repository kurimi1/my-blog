---
# Documentation: https://wowchemy.com/docs/managing-content/

title: "Pack Backend Frontend in a Docker"
subtitle: ""
summary: "小项目如何将前后端一起打包"
authors: [admin]
tags: [deploy]
categories: [总结]
date: 2022-06-08T03:44:18Z
lastmod: 2022-06-08T03:44:18Z
featured: false
draft: false

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Focal points: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight.
image:
  caption: ""
  focal_point: ""
  preview_only: false

# Projects (optional).
#   Associate this post with one or more of your projects.
#   Simply enter your project's folder or file name without extension.
#   E.g. `projects = ["internal-project"]` references `content/project/deep-learning/index.md`.
#   Otherwise, set `projects = []`.
projects: []

makth: true
diagram: true
highlight: true
---

前后端分离是主流，go也可以通过template进行服务器渲染前端，但采用主流的前端框架vue，react，flutter等有丰富的UI，且前端可以直接做CDN等优势。本文总结当一个小项目前后端分离时仅通过一个容器启动的方法。

### 通过nginx部署前端，反代到后端api

这种方式相当于一个容器里起了nginx和后端2个服务。后端需要监听端口，nginx通过访问本地端口来连接后端。

### 后端路由到前端的静态资源，前端实现反代调用后端api

后端路由设置静态文件目录，根目录/301到静态目录。

```go
r.Static("/static", "./static")
r.GET("/", func(c *gin.Context) {
  c.Redirect(http.StatusMovedPermanently, "/static/")
  return
})
```

前端axios设置base_url

```js
// 创建 axios 实例
const service = axios.create({
  baseURL: process.env.VUE_APP_API_BASE_URL, // api base_url
  timeout: 6000 // 请求超时时间
})
```

### 将前端静态资源嵌入到go二进制当中

这样做不需要复制静态文件，直接运行二进制即可。`阅读drone源码发现的`，前端是单独放在另一个仓库中的<https://github.com/drone/drone-ui>，这里的dist目录里面有两个文件dist.go和dist_gen.go。
其中dist.go的“代码”只有短短的两行：

```go
package dist

//go:generate togo http -package dist -output dist_gen.go
```

到这里就要介绍一下go generate命令了。

#### go generate是什么？

go generate 是自 Go 1.4 版本后加入的一个命令，当运行此命令时，它将扫描与当前包相关的源代码文件，找出文件中所有包含//go:generate的特殊注释，并将该注释后面的内容当做 shell 执行。
虽说是可以执行任意命令，但它往往被用作自动生成代码。为了避免自动生成的代码之后被人为修改，往往还会在生成的代码前面加上// Code generated by xxxx; DO NOT EDIT.这样的提示。  

`注意，//go:generate并不会在go build或go run时执行。只能单独使用go generate执行。`  

其实 Go 里面还有很多类似//go:xxx这样的注释。像//go:noinline //go:nosplit //go:norace 这些，大多都是控制 Go 编译器的一些命令。

回到 Drone，这里的go:generate togo http -package dist -output dist_gen.go后面的命令是使用了 Drone 作者自己开发的一个小工具togo。<<https://github.com/bradrydzewski/tog>

它可以将 HTML、SQL、JSON 等静态文件转换成 Go 文件。使我们可以直接在项目的 Go 源码中调用这些文件。togo就是个 CLI 程序，源码不多；大概看了下，基本流程就是将静态文件的内容进行简单的处理后（比如转义掉反引号）然后使用 Go 自带的模板语言template包将静态文件内容以及文件信息插入到事先写好的 Go 代码模板中。

#### 将dist_gen.go引入到项目中

Build the app and run go generate

```BASH
npm run build
# change to the dist directory
cd dist
# run go generate
GO111MODULE=off go generate ./...
```

This will update the `dist/dist_gen.go` file.

既分离了前后端项目的源代码，又通过包的方式使得前端和后端能很好的结合，妙啊！

同样是`后端路由输出静态文件`，只不过静态文件在go代码中，一起编译成二进制。

```go
func HandleIndex(host string, session core.Session, license core.LicenseService) http.HandlerFunc {
	return func(rw http.ResponseWriter, r *http.Request) {
    user, _ := session.Get(r)
		if user == nil && r.URL.Path == "/" {
			http.Redirect(rw, r, "/welcome", 303)
			return
		}

		out := dist.MustLookup("/index.html")
		ctx := r.Context()

		if ok, _ := license.Exceeded(ctx); ok {
			out = bytes.Replace(out, head, exceeded, -1)
		} else if license.Expired(ctx) {
			out = bytes.Replace(out, head, expired, -1)
		}
		rw.Header().Set("Content-Type", "text/html; charset=UTF-8")
		rw.Write(out)
	}
}
```

index.html会引用static下的js，css等因此要设置路由链接嵌入的静态文件

```go
	h := http.FileServer(dist.New())
	h = setupCache(h)
	r.Handle("/favicon.png", h)
	r.Handle("/manifest.json", h)
	r.Handle("/asset-manifest.json", h)
	r.Handle("/static/*filepath", h)
```

这里再提一下上面两个命令中的./..这个用法。它可以遍历包括当前文件夹在内的所有子文件夹。
起初看到这个还以为是操作系统的特性，但谷歌搜了半天没搜到。最后还是在 Go 的源码文档里看到了对此的解释。
> The "go list" subcommand lists the import paths corresponding to its arguments, and the pattern "./..." means start in the current directory ("./") and find all packages below that directory ("...")

#### 最后提一下将静态文件嵌入go二进制的工具很多

`togo已经不再维护`

一些开源的项目很久以前就开始做这方面的工作，比如gobuffalo/packr、markbates/pkger、rakyll/statik、knadh/stuffbin等等，但是不管怎么说这些都是第三方提供的功能，如果Go官方能内建支持就好了。2019末一个提案被提出issue#35950,期望Go官方编译器支持嵌入静态文件。后来Russ Cox专门写了一个设计文档Go command support for embedded static assets, 并最终实现了它。
